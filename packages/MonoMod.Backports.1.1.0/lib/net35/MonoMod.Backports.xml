<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MonoMod.Backports</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute">
             <summary>
             Indicates that certain members on a specified <see cref="T:System.Type"/> are accessed dynamically,
             for example through <see cref="N:System.Reflection"/>.
             </summary>
             <remarks>
             This allows tools to understand which members are being accessed during the execution
             of a program.
            
             This attribute is valid on members whose type is <see cref="T:System.Type"/> or <see cref="T:System.String"/>.
            
             When this attribute is applied to a location of type <see cref="T:System.String"/>, the assumption is
             that the string represents a fully qualified type name.
            
             When this attribute is applied to a class, interface, or struct, the members specified
             can be accessed dynamically on <see cref="T:System.Type"/> instances returned from calling
             <see cref="M:System.Object.GetType"/> on instances of that class, interface, or struct.
            
             If the attribute is applied to a method it's treated as a special case and it implies
             the attribute should be applied to the "this" parameter of the method. As such the attribute
             should only be used on instance methods of types assignable to System.Type (or string, but no methods
             will use it there).
             </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute"/> class
            with the specified member types.
            </summary>
            <param name="memberTypes">The types of members dynamically accessed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.MemberTypes">
            <summary>
            Gets the <see cref="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes"/> which specifies the type
            of members dynamically accessed.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes">
             <summary>
             Specifies the types of members that are dynamically accessed.
            
             This enumeration has a <see cref="T:System.FlagsAttribute"/> attribute that allows a
             bitwise combination of its member values.
             </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None">
            <summary>
            Specifies no members.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor">
            <summary>
            Specifies the default, parameterless public constructor.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors">
            <summary>
            Specifies all public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors">
            <summary>
            Specifies all non-public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods">
            <summary>
            Specifies all public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods">
            <summary>
            Specifies all non-public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields">
            <summary>
            Specifies all public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields">
            <summary>
            Specifies all non-public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes">
            <summary>
            Specifies all public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes">
            <summary>
            Specifies all non-public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties">
            <summary>
            Specifies all public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties">
            <summary>
            Specifies all non-public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents">
            <summary>
            Specifies all public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents">
            <summary>
            Specifies all non-public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All">
            <summary>
            Specifies all members.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute"/> class.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
                Reserved to be used by the compiler for tracking metadata.
                This class should not be used by developers in source code.
            </summary>
            <remarks>
                This definition is provided by the <i>IsExternalInit</i> NuGet package (https://www.nuget.org/packages/IsExternalInit).
                Please see https://github.com/manuelroemer/IsExternalInit for more information.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
            <summary>Gets the value of the specified key.</summary>
            <param name="key">key of the value to find. Cannot be null.</param>
            <param name="value">
            If the key is found, contains the value associated with the key upon method return.
            If the key is not found, contains default(TValue).
            </param>
            <returns>Returns "true" if key was found, "false" otherwise.</returns>
            <remarks>
            The key may get garbaged collected during the TryGetValue operation. If so, TryGetValue
            may at its discretion, return "false" and set "value" to the default (as if the key was not present.)
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
            <summary>Adds a key to the table.</summary>
            <param name="key">key to add. May not be null.</param>
            <param name="value">value to associate with key.</param>
            <remarks>
            If the key is already entered into the dictionary, this method throws an exception.
            The key may get garbage collected during the Add() operation. If so, Add()
            has the right to consider any prior entries successfully removed and add a new entry without
            throwing an exception.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryAdd(`0,`1)">
            <summary>Adds a key to the table if it doesn't already exist.</summary>
            <param name="key">The key to add.</param>
            <param name="value">The key's property value.</param>
            <returns>true if the key/value pair was added; false if the table already contained the key.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)">
            <summary>Adds the key and value if the key doesn't exist, or updates the existing key's value if it does exist.</summary>
            <param name="key">key to add or update. May not be null.</param>
            <param name="value">value to associate with key.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
            <summary>Removes a key and its value from the table.</summary>
            <param name="key">key to remove. May not be null.</param>
            <returns>true if the key is found and removed. Returns false if the key was not in the dictionary.</returns>
            <remarks>
            The key may get garbage collected during the Remove() operation. If so,
            Remove() will not fail or throw, however, the return value can be either true or false
            depending on who wins the race.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear">
            <summary>Clear all the key/value pairs</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)">
            <summary>
            Atomically searches for a specified key in the table and returns the corresponding value.
            If the key does not exist in the table, the method invokes a callback method to create a
            value that is bound to the specified key.
            </summary>
            <param name="key">key of the value to find. Cannot be null.</param>
            <param name="createValueCallback">callback that creates value for key. Cannot be null.</param>
            <returns></returns>
            <remarks>
            If multiple threads try to initialize the same key, the table may invoke createValueCallback
            multiple times with the same key. Exactly one of these calls will succeed and the returned
            value of that call will be the one added to the table and returned by all the racing GetValue() calls.
            This rule permits the table to invoke createValueCallback outside the internal table lock
            to prevent deadlocks.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
            <summary>
            Helper method to call GetValue without passing a creation delegate.  Uses Activator.CreateInstance
            to create new instances as needed.  If TValue does not have a default constructor, this will throw.
            </summary>
            <param name="key">key of the value to find. Cannot be null.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Runtime#CompilerServices#ICWTEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>Gets an enumerator for the table.</summary>
            <remarks>
            The returned enumerator will not extend the lifetime of
            any object pairs in the table, other than the one that's Current.  It will not return entries
            that have already been collected, nor will it return entries added after the enumerator was
            retrieved.  It may not return all entries that were present when the enumerat was retrieved,
            however, such as not returning entries that were collected or removed after the enumerator
            was retrieved but before they were enumerated.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.Enumerator">
            <summary>Provides an enumerator for the table.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateEntry(`0,`1)">
            <summary>Worker for adding a new key/value pair. Will resize the container if it is full.</summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container">
            <summary>
            Container holds the actual data for the table.  A given instance of Container always has the same capacity.  When we need
            more capacity, we create a new Container, copy the old one into the new one, and discard the old one.  This helps enable lock-free
            reads from the table, as readers never need to deal with motion of entries due to rehashing.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.CreateEntryNoResize(`0,`1)">
            <summary>Worker for adding a new key/value pair. Container must NOT be full.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.TryGetValueWorker(`0,`1@)">
            <summary>Worker for finding a key/value pair. Must hold _lock.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.FindEntry(`0,System.Object@)">
            <summary>
            Returns -1 if not found (if key expires during FindEntry, this can be treated as "not found.").
            Must hold _lock, or be prepared to retry the search while holding _lock.
            </summary>
            <remarks>This method requires <paramref name="value"/> to be on the stack to be properly tracked.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.TryGetEntry(System.Int32,`0@,`1@)">
            <summary>Gets the entry at the specified entry index.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.RemoveAllKeys">
            <summary>Removes all of the keys in the table.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.Remove(`0)">
            <summary>Removes the specified key from the table, if it exists.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.Resize">
            <summary>Resize, and scrub expired keys off bucket lists. Must hold _lock.</summary>
            <remarks>
            _firstEntry is less than _entries.Length on exit, that is, the table has at least one free entry.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler">
            <summary>Provides a handler used by the language compiler to process interpolated strings into <see cref="T:System.String"/> instances.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GuessedLengthPerHole">
            <summary>Expected average length of formatted data used for an individual interpolation expression result.</summary>
            <remarks>
            This is inherited from string.Format, and could be changed based on further data.
            string.Format actually uses `format.Length + args.Length * 8`, but format.Length
            includes the format items themselves, e.g. "{0}", and since it's rare to have double-digit
            numbers of items, we bump the 8 up to 11 to account for the three extra characters in "{d}",
            since the compiler-provided base length won't include the equivalent character count.
            </remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.MinimumArrayPoolLength">
            <summary>Minimum size array to rent from the pool.</summary>
            <remarks>Same as stack-allocation size used today by string.Format.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider">
            <summary>Optional provider to pass to IFormattable.ToString or ISpanFormattable.TryFormat calls.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._arrayToReturnToPool">
            <summary>Array rented from the array pool and used to back <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars">
            <summary>The span to write into.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos">
            <summary>Position at which to write the next character.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._hasCustomFormatter">
            <summary>Whether <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._provider"/> provides an ICustomFormatter.</summary>
            <remarks>
            Custom formatters are very rare.  We want to support them, but it's ok if we make them more expensive
            in order to make them as pay-for-play as possible.  So, we avoid adding another reference type field
            to reduce the size of the handler and to reduce required zero'ing, by only storing whether the provider
            provides a formatter, rather than actually storing the formatter.  This in turn means, if there is a
            formatter, we pay for the extra interface call on each AppendFormatted that needs it.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider)">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.IFormatProvider,System.Span{System.Char})">
            <summary>Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <param name="initialBuffer">A buffer temporarily transferred to the handler for use as part of its formatting.  Contents may be overwritten.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GetDefaultLength(System.Int32,System.Int32)">
            <summary>Derives a default length with which to seed the handler.</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToString">
            <summary>Gets the built <see cref="T:System.String"/>.</summary>
            <returns>The built string.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear">
            <summary>Gets the built <see cref="T:System.String"/> and clears the handler.</summary>
            <returns>The built string.</returns>
            <remarks>
            This releases any resources used by the handler. The method should be invoked only
            once and as the last thing performed on the handler. Subsequent use is erroneous, ill-defined,
            and may destabilize the process, as may using any other copies of the handler after ToStringAndClear
            is called on any one of them.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Clear">
            <summary>Clears the handler, returning any rented array to the pool.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Text">
            <summary>Gets a span of the written characters thus far.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendStringDirect(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>Writes the specified character span to the handler.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>Writes the specified string of chars to the handler.</summary>
            <param name="value">The span to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormattedSlow(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <remarks>
            Slow path to handle a custom formatter, potentially null value,
            or a string that doesn't fit in the current buffer.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.HasCustomFormatter(System.IFormatProvider)">
            <summary>Gets whether the provider provides a custom formatter.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendCustomFormatter``1(``0,System.String)">
            <summary>Formats the value using the custom formatter from the provider.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>Handles adding any padding required for aligning a formatted value in an interpolation expression.</summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">Non-zero minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.EnsureCapacityForAdditionalChars(System.Int32)">
            <summary>Ensures <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> has the capacity to store <paramref name="additionalChars"/> beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopyString(System.String)">
            <summary>Fallback for fast path in <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendStringDirect(System.String)"/> when there's not enough space in the destination.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowThenCopySpan(System.ReadOnlySpan{System.Char})">
            <summary>Fallback for <see cref="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/> for when not enough space exists in the current buffer.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow(System.Int32)">
            <summary>Grows <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to have the capacity to store at least <paramref name="additionalChars"/> beyond <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._pos"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.Grow">
            <summary>Grows the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.GrowCore(System.UInt32)">
            <summary>Grow the size of <see cref="F:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler._chars"/> to at least the specified <paramref name="requiredMinCapacity"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute">
             <summary>
             Disables the built-in runtime managed/unmanaged marshalling subsystem for
             P/Invokes, Delegate types, and unmanaged function pointer invocations.
             </summary>
             <remarks>
             <para>Note: This does nothing on runtimes older than .NET 7. It is provided entirely for forward compatibility.</para>
             The built-in marshalling subsystem has some behaviors that cannot be changed due to
             backward-compatibility requirements. This attribute allows disabling the built-in
             subsystem and instead uses the following rules for P/Invokes, Delegates,
             and unmanaged function pointer invocations:
            
             - All value types that do not contain reference type fields recursively (<c>unmanaged</c> in C#) are blittable
             - Value types that recursively have any fields that have <c>[StructLayout(LayoutKind.Auto)]</c> are disallowed from interop.
             - All reference types are disallowed from usage in interop scenarios.
             - SetLastError support in P/Invokes is disabled.
             - varargs support is disabled.
             - LCIDConversionAttribute support is disabled.
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.#ctor">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>
            This interface is required for types that want to be indexed into by dynamic patterns.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
                Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with
                element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
                Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" />
                class.
            </summary>
            <param name="transformNames">
                Specifies, in a pre-order depth-first traversal of a type's
                construction, which <see cref="T:System.ValueType" /> occurrences are
                meant to carry element names.
            </param>
            <remarks>
                This constructor is meant to be used on types that contain an
                instantiation of <see cref="T:System.ValueType" /> that contains
                element names.  For instance, if <c>C</c> is a generic type with
                two type parameters, then a use of the constructed type
                <c>C{<see cref="T:System.ValueTuple`2" />, <see cref="T:System.ValueTuple`3" /></c> might be intended to
                treat the first type argument as a tuple with element names and the
                second as a tuple without element names. In which case, the
                appropriate attribute specification should use a
                <c>transformNames</c> value of
                <code>
                    { "name1", "name2", null, null,
                    null }
                </code>
                .
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
                Specifies, in a pre-order depth-first traversal of a type's
                construction, which <see cref="T:System.ValueTuple" /> elements are
                meant to carry element names.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.MemoryMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying memory.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> and <paramref name="start" />, <paramref name="length" /> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <param name="start">The offset from the start of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <param name="length">The length of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /> to allow
            the <paramref name="memory" /> to be used in existing APIs that take an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <param name="memory">The ReadOnlyMemory to view as an <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>Attempts to get the underlying <see cref="T:System.String"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The memory that may be wrapping a <see cref="T:System.String"/> object.</param>
            <param name="text">The string.</param>
            <param name="start">The starting location in <paramref name="text"/>.</param>
            <param name="length">The number of items in <paramref name="text"/>.</param>
            <returns></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a structure of type T out of a read-only span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
            <summary>
            Reads a structure of type T out of a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the pre-pinned target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The pre-pinned target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>This method should only be called on an array that is already pinned and 
            that array should not be unpinned while the returned Memory<typeparamref name="T"/> is still in use.
            Calling this method on an unpinned array could result in memory corruption.</remarks>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="T"/> to Span of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed Int32.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="T"/> to ReadOnlySpan of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed Int32.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
            <summary>Creates a <see cref="T:System.Memory`1"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Memory`1"/> representing the same memory as the <see cref="T:System.ReadOnlyMemory`1"/>, but writable.</returns>
            <remarks>
            <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> must be used with extreme caution.  <see cref="T:System.ReadOnlyMemory`1"/> is used
            to represent immutable data and other memory that is not meant to be written to; <see cref="T:System.Memory`1"/> instances created
            by <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> should not be written to.  The method exists to enable variables typed
            as <see cref="T:System.Memory`1"/> but only used for reading to store a <see cref="T:System.ReadOnlyMemory`1"/>.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a reference to the 0th element of the ReadOnlySpan. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="T:System.Runtime.InteropServices.SequenceMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
            <summary>
            Get <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
            <summary>
            Get <see cref="T:System.ReadOnlyMemory`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.ReadOnlyMemory`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetString(System.Buffers.ReadOnlySequence{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>
            Get <see cref="T:System.String"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.String"/>, return false.
            </summary>
        </member>
        <member name="T:System.ArrayEx">
            <summary>
            Extensions to <see cref="T:System.Array"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="T:System.Buffers.ArrayPool`1">
            <summary>
            Provides a resource pool that enables reusing instances of arrays.
            </summary>
            <remarks>
            <para>
            Renting and returning buffers with an <see cref="T:System.Buffers.ArrayPool`1"/> can increase performance
            in situations where arrays are created and destroyed frequently, resulting in significant
            memory pressure on the garbage collector.
            </para>
            <para>
            This class is thread-safe.  All members may be used by multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Buffers.ArrayPool`1.Shared">
            <summary>
            Retrieves a shared <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <remarks>
            The shared pool provides a default implementation of <see cref="T:System.Buffers.ArrayPool`1"/>
            that's intended for general applicability.  It maintains arrays of multiple sizes, and
            may hand back a larger array than was actually requested, but will never hand back a smaller
            array than was requested. Renting a buffer from it with <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> will result in an
            existing buffer being taken from the pool if an appropriate buffer is available or in a new
            buffer being allocated if one is not available.
            byte[] and char[] are the most commonly pooled array types. For these we use a special pool type
            optimized for very fast access speeds, at the expense of more memory consumption.
            The shared pool instance is created lazily on first access.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using default configuration options.
            </summary>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance.</returns>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using custom configuration options.
            </summary>
            <param name="maxArrayLength">The maximum length of array instances that may be stored in the pool.</param>
            <param name="maxArraysPerBucket">
            The maximum number of array instances that may be stored in each bucket in the pool.  The pool
            groups arrays of similar lengths into buckets for faster access.
            </param>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance with the specified configuration options.</returns>
            <remarks>
            The created pool will group arrays into buckets, with no more than <paramref name="maxArraysPerBucket"/>
            in each bucket and with those arrays not exceeding <paramref name="maxArrayLength"/> in length.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Rent(System.Int32)">
            <summary>
            Retrieves a buffer that is at least the requested length.
            </summary>
            <param name="minimumLength">The minimum length of the array needed.</param>
            <returns>
            An array that is at least <paramref name="minimumLength"/> in length.
            </returns>
            <remarks>
            This buffer is loaned to the caller and should be returned to the same pool via
            <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> so that it may be reused in subsequent usage of <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>.
            It is not a fatal error to not return a rented buffer, but failure to do so may lead to
            decreased application performance, as the pool may need to create a new buffer to replace
            the one lost.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)">
            <summary>
            Returns to the pool an array that was previously obtained via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> on the same
            <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <param name="array">
            The buffer previously obtained from <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> to return to the pool.
            </param>
            <param name="clearArray">
            If <c>true</c> and if the pool will store the buffer to enable subsequent reuse, <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/>
            will clear <paramref name="array"/> of its contents so that a subsequent consumer via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>
            will not see the previous consumer's content.  If <c>false</c> or if the pool will release the buffer,
            the array's contents are left unchanged.
            </param>
            <remarks>
            Once a buffer has been returned to the pool, the caller gives up all ownership of the buffer
            and must not use it. The reference returned from a given call to <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> must only be
            returned via <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> once.  The default <see cref="T:System.Buffers.ArrayPool`1"/>
            may hold onto the returned buffer in order to rent it again, or it may release the returned buffer
            if it's determined that the pool already has enough buffers stored.
            </remarks>
        </member>
        <member name="T:System.Buffers.BuffersExtensions">
            <summary>
            Extension methods for <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0}@,``0)">
            <summary>
            Returns position of first occurrence of item in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0}@,System.Span{``0})">
            <summary>
            Copy the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to the specified <see cref="T:System.Span`1"/>.
            </summary>
            <param name="source">The source <see cref="T:System.Buffers.ReadOnlySequence`1"/>.</param>
            <param name="destination">The destination <see cref="T:System.Span`1"/>.</param>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0}@)">
            <summary>
            Converts the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to an array
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
            <summary>
            Writes contents of <paramref name="value"/> to <paramref name="writer"/>
            </summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxArrayLength">
            <summary>The default maximum length of each array in the pool (2^20).</summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxNumberOfArraysPerBucket">
            <summary>The default maximum number of arrays per bucket that are available for rent.</summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="T:System.Buffers.ConfigurableArrayPool`1.Bucket">
            <summary>Provides a thread-safe bucket containing buffers that can be Rent'd and Return'd.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the pool with numberOfBuffers arrays where each buffer is of bufferLength length.
            </summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Bucket.Id">
            <summary>Gets an ID for the bucket to use with events.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Rent">
            <summary>Takes an array from the bucket.  If the bucket is empty, returns null.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Return(`0[])">
            <summary>
            Attempts to return the buffer to the bucket.  If successful, the buffer will be stored
            in the bucket and true will be returned; otherwise, the buffer won't be stored, and false
            will be returned.
            </summary>
        </member>
        <member name="T:System.Buffers.IBufferWriter`1">
            <summary>
            Represents a <typeparam name="T"/> sink
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Requests the <see cref="T:System.Memory`1"/> that is at least <paramref name="sizeHint"/> in size if possible, otherwise returns maximum available memory.
            If <paramref name="sizeHint"/> is equal to <code>0</code>, currently available memory would get returned.
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Requests the <see cref="T:System.Span`1"/> that is at least <paramref name="sizeHint"/> in size if possible, otherwise returns maximum available memory.
            If <paramref name="sizeHint"/> is equal to <code>0</code>, currently available memory would get returned.
            </summary>
        </member>
        <member name="T:System.Buffers.IMemoryOwner`1">
            <summary>
            Owner of Memory<typeparamref name="T"/> that is responsible for disposing the underlying memory appropriately.
            </summary>
        </member>
        <member name="P:System.Buffers.IMemoryOwner`1.Memory">
            <summary>
            Returns a Memory<typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:System.Buffers.IPinnable">
            <summary>
            Provides a mechanism for pinning and unpinning objects to prevent the GC from moving them.
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Pin(System.Int32)">
            <summary>
            Call this method to indicate that the IPinnable object can not be moved by the garbage collector.
            The address of the pinned object can be taken.
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to.</param>
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Unpin">
            <summary>
            Call this method to indicate that the IPinnable object no longer needs to be pinned.
            The garbage collector is free to move the object now.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryHandle">
            <summary>
            A handle for the memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.#ctor(System.Void*,System.Runtime.InteropServices.GCHandle,System.Buffers.IPinnable)">
            <summary>
            Creates a new memory handle for the memory.
            </summary>
            <param name="pointer">pointer to memory</param>
            <param name="pinnable">reference to manually managed object, or default if there is no memory manager</param>
            <param name="handle">handle used to pin array buffers</param>
        </member>
        <member name="P:System.Buffers.MemoryHandle.Pointer">
            <summary>
            Returns the pointer to memory, where the memory is assumed to be pinned and hence the address won't change.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.Dispose">
            <summary>
            Frees the pinned handle and releases IPinnable.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryManager`1">
            <summary>
            Manager of <see cref="T:System.Memory`1"/> that provides the implementation.
            </summary>
        </member>
        <member name="P:System.Buffers.MemoryManager`1.Memory">
            <summary>
            Returns a <see cref="T:System.Memory`1"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.GetSpan">
            <summary>
            Returns a span wrapping the underlying memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Pin(System.Int32)">
            <summary>
            Returns a handle to the memory that has been pinned and hence its address can be taken.
            </summary>
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to. (default = 0)</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Unpin">
            <summary>
            Lets the garbage collector know that the object is free to be moved now.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="length">The element count in the memory, starting at offset 0.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="start">The offset to the element which the returned memory starts at.</param>
            <param name="length">The element count in the memory, starting at element offset <paramref name="start"/>.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.TryGetArray(System.ArraySegment{`0}@)">
            <summary>
            Returns an array segment.
            <remarks>Returns the default array segment if not overriden.</remarks>
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.System#IDisposable#Dispose">
            <summary>
            Implements IDisposable.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Dispose(System.Boolean)">
            <summary>
            Clean up of any leftover managed and unmanaged resources.
            </summary>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1">
            <summary>
            Represents a sequence that can read a sequential series of <typeparam name="T" />.
            </summary>
        </member>
        <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
            <summary>
            Returns empty <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Length">
            <summary>
            Length of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> is empty.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> contains a single <see cref="T:System.ReadOnlyMemory`1"/> segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.First">
            <summary>
            Gets <see cref="T:System.ReadOnlyMemory`1"/> from the first segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Start">
            <summary>
            A position to the start of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.End">
            <summary>
            A position to the end of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from linked memory list represented by start and end segments
            and corresponding indexes in them.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="!:T[]"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="!:T[]"/>, start and index.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="T:System.ReadOnlyMemory`1"/>.
            Consumer is expected to manage lifetime of memory until <see cref="T:System.Buffers.ReadOnlySequence`1"/> is not used anymore.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The end (inclusive) of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The end (inclusive) of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at '<paramref name="start"/>, with <paramref name="length"/> items
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (inclusive).
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="end">The ending (inclusive) <see cref="T:System.SequencePosition"/> of the slice</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at the existing <see cref="T:System.Buffers.ReadOnlySequence`1"/>'s end.
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at the existing <see cref="T:System.Buffers.ReadOnlySequence`1"/>'s end.
            </summary>
            <param name="start">The start index at which to begin this slice.</param>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
            <summary>
            Returns an enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the start of the sequence.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the <paramref name="origin"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
            <summary>
            Tries to retrieve next segment after <paramref name="position"/> and return its contents in <paramref name="memory"/>.
            Returns <code>false</code> if end of <see cref="T:System.Buffers.ReadOnlySequence`1"/> was reached otherwise <code>true</code>.
            Sets <paramref name="position"/> to the beginning of next segment if <paramref name="advance"/> is set to <code>true</code>.
            </summary>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
            <summary>
            An enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>Initialize the enumerator.</summary>
            <param name="sequence">The <see cref="T:System.Buffers.ReadOnlySequence`1"/> to enumerate.</param>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
            <summary>
            The current <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
            <summary>
            Moves to the next <see cref="T:System.ReadOnlyMemory`1"/> in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
            <summary>
            Represents a linked list of <see cref="T:System.ReadOnlyMemory`1"/> nodes.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
            <summary>
            The <see cref="T:System.ReadOnlyMemory`1"/> value for current node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
            <summary>
            The next node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
            <summary>
            The sum of node length before current.
            </summary>
        </member>
        <member name="T:System.Buffers.StandardFormat">
            <summary>
            Represents a standard formatting string without using an actual String. A StandardFormat consists of a character (such as 'G', 'D' or 'X')
            and an optional precision ranging from 0..99, or the special value NoPrecision.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.NoPrecision">
            <summary>
            Precision values for format that don't use a precision, or for when the precision is to be unspecified.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.MaxPrecision">
            <summary>
            The maximum valid precision value.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Symbol">
            <summary>
            The character component of the format.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Precision">
            <summary>
            The precision component of the format. Ranges from 0..9 or the special value NoPrecision.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.HasPrecision">
            <summary>
            true if Precision is a value other than NoPrecision
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.IsDefault">
            <summary>
            true if the StandardFormat == default(StandardFormat)
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
            <summary>
            Create a StandardFormat.
            </summary>
            <param name="symbol">A type-specific formatting character such as 'G', 'D' or 'X'</param>
            <param name="precision">An optional precision ranging from 0..9 or the special value NoPrecision (the default)</param>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
            <summary>
            Converts a character to a StandardFormat using the NoPrecision precision.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts a classic .NET format string into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
            <summary>
            Converts a classic .NET format string into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.GetHashCode">
            <summary>
            Compute a hash code.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.ToString">
            <summary>
            Returns the format in classic .NET format.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns false if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1">
            <summary>
            Provides an ArrayPool implementation meant to be used as the singleton returned from ArrayPool.Shared.
            </summary>
            <remarks>
            The implementation uses a tiered caching scheme, with a small per-thread cache for each array size, followed
            by a cache per array size shared by all threads, split into per-core stacks meant to be used by threads
            running on that core.  Locks are used to protect each per-core stack, because a thread can migrate after
            checking its processor number, because multiple threads could interleave on the same core, and because
            a thread is allowed to check other core's buckets if its core's bucket is empty/full.
            </remarks>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.NumBuckets">
            <summary>The number of buckets (array sizes) in the pool, one for each array length, starting from length 16.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxPerCorePerArraySizeStacks">
            <summary>Maximum number of per-core stacks to use per array size.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxBuffersPerArraySizePerCore">
            <summary>The maximum number of buffers to store in a bucket's global queue.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.t_tlsBuckets">
            <summary>A per-thread array of arrays, to cache one array per array size per thread.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._allTlsBuckets">
            <summary>Used to keep track of all thread local buckets for trimming if needed.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets">
            <summary>
            An array of per-core array stacks. The slots are lazily initialized to avoid creating
            lots of overhead for unused array sizes.
            </summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._trimCallbackCreated">
            <summary>Whether the callback to trim arrays in response to memory pressure has been created.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.CreatePerCoreLockedStacks(System.Int32)">
            <summary>Allocate a new PerCoreLockedStacks and try to store it into the <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets"/> array.</summary>
        </member>
        <member name="P:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks">
            <summary>Stores a set of stacks of arrays, with one stack per core.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.s_lockedStackCount">
            <summary>Number of locked stacks to employ.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks._perCoreStacks">
            <summary>The stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.#ctor">
            <summary>Initializes the stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPush(`0[])">
            <summary>Try to push the array into the stacks. If each is full when it's tested, the array will be dropped.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPop">
            <summary>Try to get an array from the stacks.  If each is empty when it's tested, null will be returned.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack">
            <summary>Provides a simple, bounded stack of arrays, protected by a lock.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._arrays">
            <summary>The arrays in the stack.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._count">
            <summary>Number of arrays stored in <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._arrays"/>.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack._millisecondsTimestamp">
            <summary>Timestamp set by Trim when it sees this as 0.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray">
            <summary>Wrapper for arrays stored in ThreadStatic buckets.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray.Array">
            <summary>The stored array.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.ThreadLocalArray.MillisecondsTimeStamp">
            <summary>Environment.TickCount timestamp for when this array was observed by Trim.</summary>
        </member>
        <member name="T:System.SequencePosition">
            <summary>
            Represents position in non-contiguous set of memory.
            Properties of this type should not be interpreted by anything but the type that created it.
            </summary>
        </member>
        <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
            <summary>
            Creates new <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetObject">
            <summary>
            Returns object part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetInteger">
            <summary>
            Returns integer part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.SequencePosition"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.Object"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
            <summary>
            Represents a thread-safe, unordered collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the bag.</typeparam>
            <remarks>
            <para>
            Bags are useful for storing objects when ordering doesn't matter, and unlike sets, bags support
            duplicates. <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is a thread-safe bag implementation, optimized for
            scenarios where the same thread will be both producing and consuming data stored in the bag.
            </para>
            <para>
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> accepts null reference (Nothing in Visual Basic) as a valid
            value for reference types.
            </para>
            <para>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._locals">
            <summary>The per-bag, per-thread work-stealing queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._workStealingQueues">
            <summary>The head work stealing queue in a linked list of queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._emptyToNonEmptyListTransitionCount">
            <summary>Number of times any list transitions from empty to non-empty.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> class.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>
            class that contains elements copied from the specified collection.
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
            <summary>
            Adds an object to the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="item">The object to be added to the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="item">The object to be added to the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.</param>
            <returns>Always returns true</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains the object
            removed from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> or the default value
            of <typeparamref name="T"/> if the operation failed.</param>
            <returns>true if an object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> or the default value of
            <typeparamref name="T"/> if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetCurrentThreadWorkStealingQueue(System.Boolean)">
            <summary>Gets the work-stealing queue data structure for the current thread.</summary>
            <param name="forceCreate">Whether to create a new queue if this thread doesn't have one.</param>
            <returns>The local queue object, or null if the thread doesn't have one.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetUnownedWorkStealingQueue">
            <summary>
            Try to reuse an unowned queue.  If a thread interacts with the bag and then exits,
            the bag purposefully retains its queue, as it contains data associated with the bag.
            </summary>
            <returns>The queue object, or null if no unowned queue could be gathered.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TrySteal(`0@,System.Boolean)">
            <summary>Local helper method to steal an item from any other non empty thread.</summary>
            <param name="result">To receive the item retrieved from the bag</param>
            <param name="take">Whether to remove or peek.</param>
            <returns>True if succeeded, false otherwise.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryStealFromTo(System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue,System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue,`0@,System.Boolean)">
            <summary>
            Attempts to steal from each queue starting from <paramref name="startInclusive"/> to <paramref name="endExclusive"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> elements to an existing
            one-dimensional <see cref="T:System.Array">Array</see>, starting at the specified array
            index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The <see
            cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- the number of elements in the source <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is greater than the available space from
            <paramref name="index"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyFromEachQueueToArray(`0[],System.Int32)">
            <summary>Copies from each queue to the target array, starting at the specified index.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The <see
            cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> elements to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Clear">
            <summary>
            Removes all values from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the bag.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
            <remarks>
            The items enumerated represent a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any update to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</value>
            <remarks>
            The count returned represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.DangerousCount">
            <summary>Gets the number of items stored in the bag.</summary>
            <remarks>Only provides a stable result when the bag is frozen.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is empty; otherwise, false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.GlobalQueuesLock">
            <summary>Global lock used to synchronize the queues pointer and all bag-wide operations (e.g. ToArray, Count, etc.).</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)">
            <summary>"Freezes" the bag, such that no concurrent operations will be mutating the bag when it returns.</summary>
            <param name="lockTaken">true if the global lock was taken; otherwise, false.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.UnfreezeBag(System.Boolean)">
            <summary>"Unfreezes" a bag frozen with <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)"/>.</summary>
            <param name="lockTaken">The result of the <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)"/> method.</param>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue">
            <summary>Provides a work-stealing queue data structure stored per thread.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.InitialSize">
            <summary>Initial size of the queue's array.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.StartIndex">
            <summary>Starting index for the head and tail indices.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._headIndex">
            <summary>Head index from which to steal.  This and'd with the <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask"/> is the index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._tailIndex">
            <summary>Tail index at which local pushes/pops happen. This and'd with the <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask"/> is the index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array">
            <summary>The array storing the queue's data.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask">
            <summary>Mask and'd with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._headIndex"/> and <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._tailIndex"/> to get an index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._addTakeCount">
            <summary>Numbers of elements in the queue from the local perspective; needs to be combined with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._stealCount"/> to get an actual Count.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._stealCount">
            <summary>Number of steals; needs to be combined with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._addTakeCount"/> to get an actual Count.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._currentOp">
            <summary>The current queue operation. Used to quiesce before performing operations from one thread onto another.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._frozen">
            <summary>true if this queue's lock is held as part of a global freeze.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._nextQueue">
            <summary>Next queue in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>'s set of thread-local queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._ownerThreadId">
            <summary>Thread ID that owns this queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.#ctor(System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue)">
            <summary>Initialize the WorkStealingQueue.</summary>
            <param name="nextQueue">The next queue in the linked list of work-stealing queues.</param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.IsEmpty">
            <summary>Gets whether the queue is empty.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.LocalPush(`0,System.Int64@)">
            <summary>
            Add new item to the tail of the queue.
            </summary>
            <param name="item">The item to add.</param>
            <param name="emptyToNonEmptyListTransitionCount"></param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.LocalClear">
            <summary>Clears the contents of the local queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TryLocalPop(`0@)">
            <summary>Remove an item from the tail of the queue.</summary>
            <param name="result">The removed item</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TryLocalPeek(`0@)">
            <summary>Peek an item from the tail of the queue.</summary>
            <param name="result">the peeked item</param>
            <returns>True if succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TrySteal(`0@,System.Boolean)">
            <summary>Steal an item from the head of the queue.</summary>
            <param name="result">the removed item</param>
            <param name="take">true to take the item; false to simply peek at it</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.DangerousCopyTo(`0[],System.Int32)">
            <summary>Copies the contents of this queue to the target array starting at the specified index.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.DangerousCount">
            <summary>Gets the total number of items in the queue.</summary>
            <remarks>
            This is not thread safe, only providing an accurate result either from the owning
            thread while its lock is held or from any thread while the bag is frozen.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.Operation">
            <summary>Lock-free operations performed on a queue.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.Enumerator">
            <summary>Provides an enumerator for the bag.</summary>
            <remarks>
            The original implementation of ConcurrentBag used a <see cref="T:System.Collections.Generic.List`1"/> as part of
            the GetEnumerator implementation.  That list was then changed to be an array, but array's
            GetEnumerator has different behavior than does list's, in particular for the case where
            Current is used after MoveNext returns false.  To avoid any concerns around compatibility,
            we use a custom enumerator rather than just returning array's. This enumerator provides
            the essential elements of both list's and array's enumerators.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
            <summary>Represents a thread-safe collection of keys and values.</summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2._tables">
            <summary>Internal tables of the dictionary.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2._comparer">
            <summary>Key equality comparer.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2._defaultComparer">
            <summary>Default comparer for TKey.</summary>
            <remarks>
            Used to avoid repeatedly accessing the shared default generic static, in particular for reference types where it's
            currently not devirtualized: https://github.com/dotnet/runtime/issues/10050.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2._growLockArray">
            <summary>Whether to dynamically increase the size of the striped lock.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2._budget">
            <summary>The maximum number of elements per lock before a resize operation is triggered.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.DefaultCapacity">
            <summary>The default capacity, i.e. the initial # of buckets.</summary>
            <remarks>
            When choosing this value, we are making a trade-off between the size of a very small dictionary,
            and the number of resizes when constructing a large dictionary. Also, the capacity should not be
            divisible by a small prime.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.MaxLockNumber">
            <summary>
            The maximum size of the striped lock that will not be exceeded when locks are automatically
            added as the dictionary grows.
            </summary>
            <remarks>
            The user is allowed to exceed this limit by passing
            a concurrency level larger than MaxLockNumber into the constructor.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.s_isValueWriteAtomic">
            <summary>Whether TValue is a type that can be written atomically (i.e., with no danger of torn reads).</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.IsValueWriteAtomic">
            <summary>Determines whether type TValue can be written atomically.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the default concurrency level, has the default initial capacity, and
            uses the default comparer for the key type.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the default
            comparer for the key type.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="capacity"/> is less than 0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IEnumerable`1"/>, has the default concurrency
            level, has the default initial capacity, and uses the default comparer for the key type.
            </summary>
            <param name="collection">The <see
            cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>, has the default concurrency
            level, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>,
            has the specified concurrency level, has the specified initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="concurrencyLevel">
            The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.
            </param>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements are copied to the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is less than 1.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level, has the specified initial capacity, and
            uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is less than 1. -or- <paramref name="capacity"/> is less than 0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be a null reference (Nothing
            in Visual Basic) for reference types.</param>
            <returns>
            true if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> successfully; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains too many elements.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <returns>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">
            When this method returns, <paramref name="value"/> contains the object removed from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> or the default value of <typeparamref
            name="TValue"/> if the operation failed.
            </param>
            <returns>true if an object was removed successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes a key and value from the dictionary.</summary>
            <param name="item">The <see cref="T:System.Collections.Generic.KeyValuePair`2"/> representing the key and value to remove.</param>
            <returns>
            true if the key and value represented by <paramref name="item"/> are successfully
            found and removed; otherwise, false.
            </returns>
            <remarks>
            Both the specifed key and value must match the entry in the dictionary for it to be removed.
            The key is compared using the dictionary's comparer (or the default comparer for <typeparamref name="TKey"/>
            if no comparer was provided to the dictionary when it was constructed).  The value is compared using the
            default comparer for <typeparamref name="TValue"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <see cref="P:System.Collections.Generic.KeyValuePair`2.Key"/> property of <paramref name="item"/> is a null reference.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemoveInternal(`0,`1@,System.Boolean,`1)">
            <summary>
            Removes the specified key from the dictionary if it exists and returns its associated value.
            If matchValue flag is set, the key will be removed only if is associated with a particular
            value.
            </summary>
            <param name="key">The key to search for and remove if it exists.</param>
            <param name="value">The variable into which the removed value, if found, is stored.</param>
            <param name="matchValue">Whether removal of the key is conditional on its value.</param>
            <param name="oldValue">The conditional value to compare against if <paramref name="matchValue"/> is true</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">
            When this method returns, <paramref name="value"/> contains the object from
            the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> with the specified key or the default value of
            <typeparamref name="TValue"/>, if the operation failed.
            </param>
            <returns>true if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>
            Updates the value associated with <paramref name="key"/> to <paramref name="newValue"/> if the existing value is equal
            to <paramref name="comparisonValue"/>.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>
            true if the value with <paramref name="key"/> was equal to <paramref name="comparisonValue"/> and
            replaced with <paramref name="newValue"/>; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdateInternal(`0,System.Nullable{System.Int32},`1,`1)">
            <summary>
            Updates the value associated with <paramref name="key"/> to <paramref name="newValue"/> if the existing value is equal
            to <paramref name="comparisonValue"/>.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="nullableHashcode">The hashcode computed for <paramref name="key"/>.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>
            true if the value with <paramref name="key"/> was equal to <paramref name="comparisonValue"/> and
            replaced with <paramref name="newValue"/>; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an array of type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>,
            starting at the specified array index.
            </summary>
            <param name="array">
            The one-dimensional array of type <see cref="T:System.Collections.Generic.KeyValuePair`2"/> that is the destination of the <see
            cref="T:System.Collections.Generic.KeyValuePair`2"/> elements copied from the <see  cref="T:System.Collections.ICollection"/>. The array must have zero-based indexing.
            </param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>. -or- The number of
            elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to
            the end of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
            <summary>
            Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> to a
            new array.
            </summary>
            <returns>A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToPairs(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.</summary>
            <remarks>Important: the caller must hold all locks in _locks before calling CopyToPairs.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToEntries(System.Collections.DictionaryEntry[],System.Int32)">
            <summary>Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.</summary>
            <remarks>Important: the caller must hold all locks in _locks before calling CopyToPairs.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToObjects(System.Object[],System.Int32)">
            <summary>Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.</summary>
            <remarks>Important: the caller must hold all locks in _locks before calling CopyToPairs.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Enumerator">
            <summary>Provides an enumerator implementation for the dictionary.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAddInternal(`0,System.Nullable{System.Int32},`1,System.Boolean,System.Boolean,`1@)">
            <summary>
            Shared internal implementation for inserts and updates.
            If key exists, we always return false; and if updateIfExists == true we force update with value;
            If key doesn't exist, we always add value and return true;
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
            <summary>Gets or sets the value associated with the specified key.</summary>
            <param name="key">The key of the value to get or set.</param>
            <value>
            The value associated with the specified key. If the specified key is not found, a get operation throws a
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>, and a set operation creates a new element with the specified key.
            </value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and <paramref name="key"/> does not exist in the collection.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ThrowKeyNotFoundException(`0)">
            <summary>Throws a KeyNotFoundException.</summary>
            <remarks>Separate from ThrowHelper to avoid boxing at call site while reusing this generic instantiation.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" />
            that is used to determine equality of keys for the dictionary.
            </summary>
            <value>
            The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface implementation
            that is used to determine equality of keys for the current
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> and to provide hash values for the keys.
            </value>
            <remarks>
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> requires an equality implementation to determine
            whether keys are equal. You can specify an implementation of the <see cref="T:System.Collections.Generic.IEqualityComparer`1" />
            generic interface by using a constructor that accepts a comparer parameter;
            if you do not specify one, the default generic equality comparer <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" /> is used.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <value>The number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetCountInternal">
            <summary>
            Gets the number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>. Should only be used after all locks
            have been acquired.
            </summary>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <value>The number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArgument">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">the value to be added, if the key does not already exist</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValueFactory">The function used to generate a value for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="addValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValueFactory">The function used to generate a value for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="addValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either the result of addValueFactory (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValue">The value to be added for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key based on
            the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either the value of addValue (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty; otherwise,
            false.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            Adds the specified key and value to the <see
            cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            An element with the same key already exists in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully remove; otherwise false. This method also returns
            false if
            <paramref name="key"/> was not found in the original <see
            cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
            <summary>
            Gets a collection containing the keys in the <see
            cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
            <summary>
            Gets a collection containing the values in the <see
            cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in
            the
            <see cref="T:System.Collections.Generic.Dictionary`2"/>.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds the specified value to the <see cref="T:System.Collections.Generic.ICollection`1"/>
            with the specified key.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            structure representing the key and value to add to the <see
            cref="T:System.Collections.Generic.Dictionary`2"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="keyValuePair"/> of <paramref
            name="keyValuePair"/> is null.</exception>
            <exception cref="T:System.OverflowException">The <see
            cref="T:System.Collections.Generic.Dictionary`2"/>
            contains too many elements.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the
            <see cref="T:System.Collections.Generic.Dictionary`2"/></exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/>
            contains a specific key and value.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            structure to locate in the <see
            cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>true if the <paramref name="keyValuePair"/> is found in the <see
            cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the dictionary is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Generic.Dictionary`2"/>, this property always returns
            false.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="keyValuePair">The <see
            cref="T:System.Collections.Generic.KeyValuePair`2"/>
            structure representing the key and value to remove from the <see
            cref="T:System.Collections.Generic.Dictionary`2"/>.</param>
            <returns>true if the key and value represented by <paramref name="keyValuePair"/> is successfully
            found and removed; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">The Key property of <paramref
            name="keyValuePair"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">The object to use as the key.</param>
            <param name="value">The object to use as the value.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="key"/> is of a type that is not assignable to the key type <typeparamref
            name="TKey"/> of the <see cref="T:System.Collections.Generic.Dictionary`2"/>. -or-
            <paramref name="value"/> is of a type that is not assignable to <typeparamref name="TValue"/>,
            the type of values in the <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            -or- A value with the same key already exists in the <see
            cref="T:System.Collections.Generic.Dictionary`2"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Gets whether the <see cref="T:System.Collections.IDictionary"/> contains an
            element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see
            cref="T:System.Collections.IDictionary"/>.</param>
            <returns>true if the <see cref="T:System.Collections.IDictionary"/> contains
            an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"> <paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.IDictionaryEnumerator"/> for the
            <see cref="T:System.Collections.IDictionary"/>.</summary>
            <returns>An <see cref="T:System.Collections.IDictionaryEnumerator"/> for the <see
            cref="T:System.Collections.IDictionary"/>.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.IDictionary"/> has a fixed size.
            </summary>
            <value>true if the <see cref="T:System.Collections.IDictionary"/> has a
            fixed size; otherwise, false. For <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.IDictionary"/> is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.IDictionary"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.IDictionary"/>.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <value>The value associated with the specified key, or a null reference (Nothing in Visual Basic)
            if <paramref name="key"/> is not in the dictionary or <paramref name="key"/> is of a type that is
            not assignable to the key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">
            A value is being assigned, and <paramref name="key"/> is of a type that is not assignable to the
            key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>. -or- A value is being
            assigned, and <paramref name="key"/> is of a type that is not assignable to the value type
            <typeparamref name="TValue"/> of the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an array, starting
            at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from
            the <see cref="T:System.Collections.ICollection"/>. The array must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than
            the length of the <paramref name="array"/>. -or- The number of elements in the source <see
            cref="T:System.Collections.ICollection"/>
            is greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            (thread safe); otherwise, false. For <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GrowTable(System.Collections.Concurrent.ConcurrentDictionary{`0,`1}.Tables)">
            <summary>
            Replaces the bucket table with a larger one. To prevent multiple threads from resizing the
            table as a result of races, the Tables instance that holds the table of buckets deemed too
            small is passed in as an argument to GrowTable(). GrowTable() obtains a lock, and then checks
            the Tables instance has been replaced in the meantime or not.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.DefaultConcurrencyLevel">
            <summary>The number of concurrent writes for which to optimize by default.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireAllLocks(System.Int32@)">
            <summary>
            Acquires all locks for this hash table, and increments locksAcquired by the number
            of locks that were successfully acquired. The locks are acquired in an increasing
            order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireLocks(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Acquires a contiguous range of locks for this hash table, and increments locksAcquired
            by the number of locks that were successfully acquired. The locks are acquired in an
            increasing order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ReleaseLocks(System.Int32,System.Int32)">
            <summary>
            Releases a contiguous range of locks.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetKeys">
            <summary>
            Gets a collection containing the keys in the dictionary.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetValues">
            <summary>
            Gets a collection containing the values in the dictionary.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Node">
            <summary>
            A node in a singly-linked list representing a particular hash table bucket.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Tables">
            <summary>Tables that hold the internal state of the ConcurrentDictionary</summary>
            <remarks>
            Wrapping the three tables in a single object allows us to atomically
            replace all tables at once.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.Tables._buckets">
            <summary>A singly-linked list for each bucket.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.Tables._locks">
            <summary>A set of locks, each guarding a section of the table.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.Tables._countPerLock">
            <summary>The number of elements guarded by each lock.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentDictionary`2.Tables._fastModBucketsMultiplier">
            <summary>Pre-computed multiplier for use on 64-bit performing faster modulo operations.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Tables.GetBucket(System.Int32)">
            <summary>Computes a ref to the bucket for a particular key.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Tables.GetBucketAndLock(System.Int32,System.UInt32@)">
            <summary>Computes the bucket and lock number for a particular key.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.DictionaryEnumerator">
            <summary>
            A private class to represent enumeration over the dictionary that implements the
            IDictionaryEnumerator interface.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
            <summary>
            Represents a thread-safe first-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1.InitialSegmentLength">
            <summary>Initial length of the segments used in the queue.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1.MaxSegmentLength">
            <summary>
            Maximum length of the segments used in the queue.  This is a somewhat arbitrary limit:
            larger means that as long as we don't exceed the size, we avoid allocating more segments,
            but if we do exceed it, then the segment becomes garbage.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._crossSegmentLock">
            <summary>
            Lock used to protect cross-segment operations, including any updates to <see cref="F:System.Collections.Concurrent.ConcurrentQueue`1._tail"/> or <see cref="F:System.Collections.Concurrent.ConcurrentQueue`1._head"/>
            and any operations that need to get a consistent view of them.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._tail">
            <summary>The current tail segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._head">
            <summary>The current head segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> class.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> class that contains elements copied
            from the specified collection.
            </summary>
            <param name="collection">
            The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array">Array</see> that is the destination of the
            elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. <paramref name="array"/> must have
            zero-based indexing.
            </param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will always add the object to the
            end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            and return true.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will attempt to remove the object
            from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
            <summary>Copies the elements stored in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> to a new array.</summary>
            <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetCount(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32,System.Int32)">
            <summary>Computes the number of items in a segment based on a fixed head and tail in that segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetCount(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32,System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32)">
            <summary>Gets the number of items in snapped region.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> elements to an existing one-dimensional <see
            cref="T:System.Array">Array</see>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. The <see cref="T:System.Array">Array</see> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the queue.  It does not reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.SnapForObservation(System.Collections.Concurrent.ConcurrentQueueSegment{`0}@,System.Int32@,System.Collections.Concurrent.ConcurrentQueueSegment{`0}@,System.Int32@)">
            <summary>
            Gets the head and tail information of the current contents of the queue.
            After this call returns, the specified region can be enumerated any number
            of times and will not change.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetItemWhenAvailable(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32)">
            <summary>Gets the item stored in the <paramref name="i"/>th entry in <paramref name="segment"/>.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
            <summary>Adds an object to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</summary>
            <param name="item">
            The object to add to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            The value can be a null reference (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.EnqueueSlow(`0)">
            <summary>Adds to the end of the queue, adding a new segment if necessary.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Attempts to remove and return the object at the beginning of the <see
            cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the beginning of the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> successfully; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeueSlow(`0@)">
            <summary>Tries to dequeue an item, removing empty segments as needed.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            without removing it.
            </summary>
            <param name="result">
            When this method returns, <paramref name="result"/> contains an object from
            the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> or default(T)
            if the operation failed.
            </param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/>
            property is recommended rather than peeking.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@,System.Boolean)">
            <summary>Attempts to retrieve the value for the first element in the queue.</summary>
            <param name="result">The value of the first element, if found.</param>
            <param name="resultUsed">true if the result is needed; otherwise false if only the true/false outcome is needed.</param>
            <returns>true if an element was found; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueueSegment`1">
            <summary>
            Provides a multi-producer, multi-consumer thread-safe bounded segment.  When the queue is full,
            enqueues fail and return false.  When the queue is empty, dequeues fail and return null.
            These segments are linked together to form the unbounded <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._slots">
            <summary>The array of items in this queue.  Each slot contains the item in that slot and its "sequence number".</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._slotsMask">
            <summary>Mask for quickly accessing a position within the queue's array.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._headAndTail">
            <summary>The head and tail positions, with padding to help avoid false sharing contention.</summary>
            <remarks>Dequeuing happens from the head, enqueuing happens at the tail.</remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._preservedForObservation">
            <summary>Indicates whether the segment has been marked such that dequeues don't overwrite the removed data.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._frozenForEnqueues">
            <summary>Indicates whether the segment has been marked such that no additional items may be enqueued.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._nextSegment">
            <summary>The segment following this one in the queue, or null if this segment is the last in the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.#ctor(System.Int32)">
            <summary>Creates the segment.</summary>
            <param name="boundedLength">
            The maximum number of elements the segment can contain.  Must be a power of 2.
            </param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.Capacity">
            <summary>Gets the number of elements this segment can store.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.FreezeOffset">
            <summary>Gets the "freeze offset" for this segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.EnsureFrozenForEnqueues">
            <summary>
            Ensures that the segment will not accept any subsequent enqueues that aren't already underway.
            </summary>
            <remarks>
            When we mark a segment as being frozen for additional enqueues,
            we set the <see cref="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._frozenForEnqueues"/> bool, but that's mostly
            as a small helper to avoid marking it twice.  The real marking comes
            by modifying the Tail for the segment, increasing it by this
            <see cref="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.FreezeOffset"/>.  This effectively knocks it off the
            sequence expected by future enqueuers, such that any additional enqueuer
            will be unable to enqueue due to it not lining up with the expected
            sequence numbers.  This value is chosen specially so that Tail will grow
            to a value that maps to the same slot but that won't be confused with
            any other enqueue/dequeue sequence number.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryDequeue(`0@)">
            <summary>Tries to dequeue an element from the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryPeek(`0@,System.Boolean)">
            <summary>Tries to peek at an element from the queue, without removing it.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryEnqueue(`0)">
            <summary>
            Attempts to enqueue the item.  If successful, the item will be stored
            in the queue and true will be returned; otherwise, the item won't be stored, and false
            will be returned.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot">
            <summary>Represents a slot in the queue.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot.Item">
            <summary>The item.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot.SequenceNumber">
            <summary>The sequence number for this slot, used to synchronize between enqueuers and dequeuers.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.PaddedHeadAndTail">
            <summary>Padded head and tail indices, to avoid false sharing between producers and consumers.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
            <summary>
            Represents a thread-safe last-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the stack.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentStack`1.Node">
            <summary>
            A simple (internal) node type used to store elements of concurrent stacks and queues.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Node.#ctor(`0)">
            <summary>
            Constructs a new node with the specified value and no next node.
            </summary>
            <param name="value">The value of the node.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            class.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            class that contains elements copied from the specified collection
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the contents of the stack from an existing collection.
            </summary>
            <param name="collection">A collection from which to copy elements.</param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The <see cref="T:System.Array"/> must
            have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> elements to an existing one-dimensional <see
            cref="T:System.Array"/>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The <see cref="T:System.Array"/> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
            <summary>
            Inserts an object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <param name="item">The object to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The value can be
            a null reference (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
            <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> atomically.
            </summary>
            <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)"/> one item at a time.  Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed.  Items at lower indices in
            the <paramref name="items"/> array will be pushed before items at higher indices.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
            <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> atomically.
            </summary>
            <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="startIndex">The zero-based offset in <paramref name="items"/> at which to begin
            inserting elements onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="count">The number of elements to be inserted onto the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> or <paramref
            name="count"/> is negative. Or <paramref name="startIndex"/> is greater than or equal to the length
            of <paramref name="items"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="startIndex"/> + <paramref name="count"/> is
            greater than the length of <paramref name="items"/>.</exception>
            <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)"/> one item at a time. Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed. Items at lower indices in the
            <paramref name="items"/> array will be pushed before items at higher indices.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushCore(System.Collections.Concurrent.ConcurrentStack{`0}.Node,System.Collections.Concurrent.ConcurrentStack{`0}.Node)">
            <summary>
            Push one or many nodes into the stack, if head and tails are equal then push one node to the stack other wise push the list between head
            and tail to the stack
            </summary>
            <param name="head">The head pointer to the new list</param>
            <param name="tail">The tail pointer to the new list</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ValidatePushPopRangeInput(`0[],System.Int32,System.Int32)">
            <summary>
            Local helper function to validate the Pop Push range methods input
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this operation
            will always insert the object onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            and return true.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> or an
            unspecified value if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
            <summary>
            Attempts to pop and return the object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
            <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            atomically.
            </summary>
            <param name="items">
            The <see cref="T:System.Array"/> to which objects popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> will be added.
            </param>
            <returns>The number of objects successfully popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted in
            <paramref name="items"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null argument (Nothing
            in Visual Basic).</exception>
            <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)"/>
            once per item to be removed.  Nodes fill the <paramref name="items"/>
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
            <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            atomically.
            </summary>
            <param name="items">
            The <see cref="T:System.Array"/> to which objects popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> will be added.
            </param>
            <param name="startIndex">The zero-based offset in <paramref name="items"/> at which to begin
            inserting elements from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="count">The number of elements to be popped from top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted into <paramref name="items"/>.</param>
            <returns>The number of objects successfully popped from the top of
            the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted in <paramref name="items"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> or <paramref
            name="count"/> is negative. Or <paramref name="startIndex"/> is greater than or equal to the length
            of <paramref name="items"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="startIndex"/> + <paramref name="count"/> is
            greater than the length of <paramref name="items"/>.</exception>
            <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)"/>
            once per item to be removed.  Nodes fill the <paramref name="items"/>
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(`0@)">
            <summary>
            Local helper function to Pop an item from the stack, slow path
            </summary>
            <param name="result">The popped item</param>
            <returns>True if succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(System.Int32,System.Collections.Concurrent.ConcurrentStack{`0}.Node@)">
            <summary>
            Slow path helper for TryPop. This method assumes an initial attempt to pop an element
            has already occurred and failed, so it begins spinning right away.
            </summary>
            <param name="count">The number of items to pop.</param>
            <param name="poppedHead">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>The number of objects successfully popped from the top of
            the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyRemovedItems(System.Collections.Concurrent.ConcurrentStack{`0}.Node,`0[],System.Int32,System.Int32)">
            <summary>
            Local helper function to copy the popped elements into a given collection
            </summary>
            <param name="head">The head of the list to be copied</param>
            <param name="collection">The collection to place the popped items in</param>
            <param name="startIndex">the beginning of index of where to place the popped items</param>
            <param name="nodesCount">The number of nodes.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this operation will attempt to pope the object at
            the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
            <summary>
            Copies the items stored in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToList">
            <summary>
            Returns an array containing a snapshot of the list's contents, using
            the target list node as the head of a region in the list.
            </summary>
            <returns>A list of the stack's contents.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToList(System.Collections.Concurrent.ConcurrentStack{`0}.Node)">
            <summary>
            Returns an array containing a snapshot of the list's contents starting at the specified node.
            </summary>
            <returns>A list of the stack's contents starting at the specified node.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the stack.  It does not reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the stack.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through
            the collection.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not
            reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator"/> was called. The enumerator is safe to use concurrently with reads
            from and writes to the stack.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
            <summary>
            A common interface for all concurrent collections.
            Defines methods to manipulate thread-safe collections intended for producer/consumer usage.
            </summary>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
            <remarks>
            All implementations of this interface must enable all members of this interface
            to be used concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to
            an
            <see cref="T:System.Array"/>, starting at a specified index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="item"/> was invalid for this collection.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the object was removed and returned successfully, <paramref
            name="item"/> contains the removed object. If no object was available to be removed, the value is
            unspecified.
            </param>
            <returns>true if an object was removed and returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
            <summary>
            Copies the elements contained in the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to a new array.
            </summary>
            <returns>A new array containing the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1">
            <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
            <param name="collection">A collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
            <summary>
            Represents a particular manner of splitting an orderable data source into multiple partitions.
            </summary>
            <typeparam name="TSource">Type of the elements in the collection.</typeparam>
            <remarks>
            <para>
            Each element in each partition has an integer index associated with it, which determines the relative
            order of that element against elements in other partitions.
            </para>
            <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1"/> must adhere to the following rules:
            <ol>
            <li>All indices must be unique, such that there may not be duplicate indices. If all indices are not
            unique, the output ordering may be scrambled.</li>
            <li>All indices must be non-negative. If any indices are negative, consumers of the implementation
            may throw exceptions.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> should throw a
            <see cref="T:System.ArgumentOutOfRangeException"/> if the requested partition count is less than or
            equal to zero.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> should always return a number
            of enumerables equal to the requested partition count. If the partitioner runs out of data and cannot
            create as many partitions as requested, an empty enumerator should be returned for each of the
            remaining partitions. If this rule is not followed, consumers of the implementation may throw a <see
            cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/>, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/>,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/>, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/>
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/>, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/>,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/>, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/>
            should always return partitions that can fully and uniquely enumerate the input data source. All of
            the data and only the data contained in the input source should be enumerated, with no duplication
            that was not already in the input, unless specifically required by the particular partitioner's
            design. If this is not followed, the output ordering may be scrambled.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition"/> returns true, each partition must return elements
            with increasing key indices.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions"/> returns true, all the keys in partition numbered N
            must be larger than all the keys in partition numbered N-1.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized"/> returns true, all indices must be monotonically increasing from
            0, though not necessarily within a single partition.</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1"/> class with the
            specified constraints on the index keys.
            </summary>
            <param name="keysOrderedInEachPartition">
            Indicates whether the elements in each partition are yielded in the order of
            increasing keys.
            </param>
            <param name="keysOrderedAcrossPartitions">
            Indicates whether elements in an earlier partition always come before
            elements in a later partition. If true, each element in partition 0 has a smaller order key than
            any element in partition 1, each element in partition 1 has a smaller order key than any element
            in partition 2, and so on.
            </param>
            <param name="keysNormalized">
            Indicates whether keys are normalized. If true, all order keys are distinct
            integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but
            only their relative order is considered, not their absolute values.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the specified number of orderable partitions.
            </summary>
            <remarks>
            Each partition is represented as an enumerator over key-value pairs.
            The value of the pair is the element itself, and the key is an integer which determines
            the relative ordering of this element against other elements in the data source.
            </remarks>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable`1"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            Each partition is represented as an enumerator over key-value pairs. The value in the pair is the element
            itself, and the key is an integer which determines the relative ordering of this element against
            other elements.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">SupportsDynamicPartitions</see>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
            <summary>
            Gets whether elements in each partition are yielded in the order of increasing keys.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
            <summary>
            Gets whether elements in an earlier partition always come before elements in a later partition.
            </summary>
            <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions"/> returns true, each element in partition 0 has a
            smaller order key than any element in partition 1, each element in partition 1 has a smaller
            order key than any element in partition 2, and so on.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
            <summary>
            Gets whether order keys are normalized.
            </summary>
            <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized"/> returns true, all order keys are distinct integers in the range
            [0 .. numberOfElements-1]. If the property returns false, order keys must still be distinct, but
            only their relative order is considered, not their absolute values.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the given number of ordered partitions.
            </summary>
            <remarks>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> except
            that the returned set of partitions does not provide the keys for the elements.
            </remarks>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable`1"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/> except
            that the returned set of partitions does not provide the keys for the elements.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.OrderablePartitioner`1.EnumerableDropIndices">
            <summary>
            Converts an enumerable over key-value pairs to an enumerable over values.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner`1">
            <summary>
            Represents a particular manner of splitting a data source into multiple partitions.
            </summary>
            <typeparam name="TSource">Type of the elements in the collection.</typeparam>
            <remarks>
            <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.Partitioner`1"/> must adhere to the following rules:
            <ol>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> should throw a
            <see cref="T:System.ArgumentOutOfRangeException"/> if the requested partition count is less than or
            equal to zero.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> should always return a number of enumerables equal to the requested
            partition count. If the partitioner runs out of data and cannot create as many partitions as
            requested, an empty enumerator should be returned for each of the remaining partitions. If this rule
            is not followed, consumers of the implementation may throw a <see
            cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/>
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/> should always return
            partitions that can fully and uniquely enumerate the input data source. All of the data and only the
            data contained in the input source should be enumerated, with no duplication that was not already in
            the input, unless specifically required by the particular partitioner's design. If this is not
            followed, the output ordering may be scrambled.</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the given number of partitions.
            </summary>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
            <summary>
            Gets whether additional partitions can be created dynamically.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Concurrent.Partitioner`1"/> can create partitions dynamically as they are
            requested; false if the <see cref="T:System.Collections.Concurrent.Partitioner`1"/> can only allocate
            partitions statically.
            </returns>
            <remarks>
            <para>
            If a derived class does not override and implement <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/>,
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/> should return false. The value of <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/> should not vary over the lifetime of this instance.
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable`1"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner">
            <summary>
            Provides common partitioning strategies for arrays, lists, and enumerables.
            </summary>
            <remarks>
            <para>
            The static methods on <see cref="T:System.Collections.Concurrent.Partitioner"/> are all thread-safe and may be used concurrently
            from multiple threads. However, while a created partitioner is in use, the underlying data source
            should not be modified, whether from the same thread that's using a partitioner or from a separate
            thread.
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>
            Creates an orderable partitioner from an <see cref="T:System.Collections.Generic.IList`1"/>
            instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source list.</typeparam>
            <param name="list">The list to be partitioned.</param>
            <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically
            load balance between partitions rather than statically partition.
            </param>
            <returns>
            An orderable partitioner based on the input list.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Array"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source array.</typeparam>
            <param name="array">The array to be partitioned.</param>
            <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically load balance
            between partitions rather than statically partition.
            </param>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source enumerable.</typeparam>
            <param name="source">The enumerable to be partitioned.</param>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
            <remarks>
            The ordering used in the created partitioner is determined by the natural order of the elements
            as retrieved from the source enumerable.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source enumerable.</typeparam>
            <param name="source">The enumerable to be partitioned.</param>
            <param name="partitionerOptions">Options to control the buffering behavior of the partitioner.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="partitionerOptions"/> argument specifies an invalid value for <see
            cref="T:System.Collections.Concurrent.EnumerablePartitionerOptions"/>.
            </exception>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
            <remarks>
            The ordering used in the created partitioner is determined by the natural order of the elements
            as retrieved from the source enumerable.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <remarks>if ProccessorCount == 1, for correct rangeSize calculation the const CoreOversubscriptionRate must be > 1 (avoid division by 1)</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <param name="rangeSize">The size of each subrange.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="rangeSize"/> argument is
            less than or equal to 0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <remarks>if ProccessorCount == 1, for correct rangeSize calculation the const CoreOversubscriptionRate must be > 1 (avoid division by 1),
            and the same issue could occur with rangeSize == -1 when fromInclusive = int.MinValue and toExclusive = int.MaxValue.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <param name="rangeSize">The size of each subrange.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="rangeSize"/> argument is
            less than or equal to 0.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2">
            <summary>
            DynamicPartitionEnumerator_Abstract defines the enumerator for each partition for the dynamic load-balance
            partitioning algorithm.
            - Partition is an enumerator of KeyValuePairs, each corresponding to an item in the data source:
              the key is the index in the source collection; the value is the item itself.
            - a set of such partitions share a reader over data source. The type of the reader is specified by
              TSourceReader.
            - each partition requests a contiguous chunk of elements at a time from the source data. The chunk
              size is initially 1, and doubles every time until it reaches the maximum chunk size.
              The implementation for GrabNextChunk() method has two versions: one for data source of IndexRange
              types (IList and the array), one for data source of IEnumerable.
            - The method "Reset" is not supported for any partitioning algorithm.
            - The implementation for MoveNext() method is same for all dynamic partitioners, so we provide it
              in this abstract class.
            </summary>
            <typeparam name="TSource">Type of the elements in the data source</typeparam>
            <typeparam name="TSourceReader">Type of the reader on the data source</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.GrabNextChunk(System.Int32)">
            <summary>
            Abstract method to request a contiguous chunk of elements from the source collection
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize)
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.HasNoElementsLeft">
            <summary>
            Abstract property, returns whether or not the shared reader has already read the last
            element of the source data
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Current">
            <summary>
            Get the current element in the current partition. Property required by IEnumerator interface
            This property is abstract because the implementation is different depending on the type
            of the source data: IList, Array or IEnumerable
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Dispose">
            <summary>
            Dispose is abstract, and depends on the type of the source data:
            - For source data type IList and Array, the type of the shared reader is just the data itself.
              We don't do anything in Dispose method for IList and Array.
            - For source data type IEnumerable, the type of the shared reader is an enumerator we created.
              Thus we need to dispose this shared reader enumerator, when there is no more active partitions
              left.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Reset">
            <summary>
            Reset on partitions is not supported
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.System#Collections#IEnumerator#Current">
            <summary>
            Get the current element in the current partition. Property required by IEnumerator interface
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.MoveNext">
            <summary>
            Moves to the next element if any.
            Try current chunk first, if the current chunk do not have any elements left, then we
            attempt to grab a chunk from the source collection.
            </summary>
            <returns>
            true if successfully moving to the next position;
            false otherwise, if and only if there is no more elements left in the current chunk
            AND the source collection is exhausted.
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIEnumerator defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
            <param name="partitionCount">number of partitions requested</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderableDynamicPartitions">
            <summary>
            Overrides OrderablePartitioner.GetOrderableDynamicPartitions
            </summary>
            <returns>a enumerable collection of orderable partitions</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.SupportsDynamicPartitions">
            <summary>
            Whether additional partitions can be created dynamically.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable">
            <summary>
            Provides customized implementation for source data of IEnumerable
            Different from the counterpart for IList/Array, this enumerable maintains several additional fields
            shared by the partitions it owns, including a boolean "_hasNoElementsLef", a shared lock, and a
            shared count "_activePartitionCount" used to track active partitions when they were created statically
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            This is the common entry point for consuming items from the source enumerable
            </summary>
            <returns>
            true if we successfully reserved at least one element
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk_Single(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            Version of GrabChunk that grabs a single element at a time from the source enumerable
            </summary>
            <returns>
            true if we successfully reserved an element
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk_Buffered(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            Version of GrabChunk that uses buffering scheme to grab items out of source enumerable
            </summary>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize)
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumerator_Abstract directly
            Provides customized implementation for: GrabNextChunk, HasNoElementsLeft, Current, Dispose
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.GrabNextChunk(System.Int32)">
            <summary>
            Reserves a contiguous range of elements from source data
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize)
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.HasNoElementsLeft">
            <summary>
            Returns whether or not the shared reader has already read the last
            element of the source data
            </summary>
            <remarks>
            We cannot call _sharedReader.MoveNext(), to see if it hits the last element
            or not, because we can't undo MoveNext(). Thus we need to maintain a shared
            boolean value _hasNoElementsLeft across all partitions
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2">
            <summary>
            Dynamic load-balance partitioner. This class is abstract and to be derived from by
            the customized partitioner classes for IList, Array, and IEnumerable
            </summary>
            <typeparam name="TSource">Type of the elements in the source data</typeparam>
            <typeparam name="TCollection"> Type of the source data collection</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.#ctor(`1)">
            <summary>
            Constructs a new orderable partitioner
            </summary>
            <param name="data">source data collection</param>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions_Factory(`1)">
            <summary>
            Partition the source data and create an enumerable over the resulting partitions.
            </summary>
            <param name="data">the source data collection</param>
            <returns>an enumerable of partitions of </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
            <param name="partitionCount">number of partitions requested</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions">
            <summary>
            Overrides OrderablePartitioner.GetOrderableDynamicPartitions
            </summary>
            <returns>a enumerable collection of orderable partitions</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.SupportsDynamicPartitions">
            <summary>
            Whether additional partitions can be created dynamically.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2">
            <summary>
            Defines dynamic partition for source data of IList and Array.
            This class inherits DynamicPartitionEnumerator_Abstract
              - implements GrabNextChunk, HasNoElementsLeft, and Dispose methods for IList and Array
              - Current property still remains abstract, implementation is different for IList and Array
              - introduces another abstract method SourceCount, which returns the number of elements in
                the source data. Implementation differs for IList and Array
            </summary>
            <typeparam name="TSource">Type of the elements in the data source</typeparam>
            <typeparam name="TSourceReader">Type of the reader on the source data</typeparam>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.SourceCount">
            <summary>
            Get the number of elements from the source reader.
            It calls IList.Count or Array.Length
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.GrabNextChunk(System.Int32)">
            <summary>
            Reserves a contiguous range of elements from source data
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize)
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.HasNoElementsLeft">
            <summary>
            Returns whether or not the shared reader has already read the last
            element of the source data
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.Dispose">
            <summary>
            For source data type IList and Array, the type of the shared reader is just the data itself.
            We don't do anything in Dispose method for IList and Array.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIList defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerable">
            <summary>
            Inherits from PartitionList_Abstract
            Provides customized implementation for source data of IList
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for IList
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator.Current">
            <summary>
            return a KeyValuePair of the current element and its key
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForArray defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerable">
            <summary>
            Inherits from PartitionList_Abstract
            Provides customized implementation for source data of Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2">
            <summary>
            Static partitioning over IList.
            - dynamic and load-balance
            - Keys are ordered within each partition
            - Keys are ordered across partitions
            - Keys are normalized
            - Number of partitions is fixed once specified, and the elements of the source data are
            distributed to each partition as evenly as possible.
            </summary>
            <typeparam name="TSource">type of the elements</typeparam>
            <typeparam name="TCollection">Type of the source data collection</typeparam>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.SourceCount">
            <summary>
            Abstract method to return the number of elements in the source data
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.CreatePartition(System.Int32,System.Int32)">
            <summary>
            Abstract method to create a partition that covers a range over source data,
            starting from "startIndex", ending at "endIndex"
            </summary>
            <param name="startIndex">start index of the current partition on the source data</param>
            <param name="endIndex">end index of the current partition on the source data</param>
            <returns>a partition enumerator over the specified range</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions
            Return a list of partitions, each of which enumerate a fixed part of the source data
            The elements of the source data are distributed to each partition as evenly as possible.
            Specifically, if the total number of elements is N, and number of partitions is x, and N = a*x +b,
            where a is the quotient, and b is the remainder. Then the first b partitions each has a + 1 elements,
            and the last x-b partitions each has a elements.
            For example, if N=10, x =3, then
               partition 0 ranges [0,3],
               partition 1 ranges [4,6],
               partition 2 ranges [7,9].
            This also takes care of the situation of (x&gt;N), the last x-N partitions are empty enumerators.
            An empty enumerator is indicated by
                 (_startIndex == list.Count &amp;&amp; _endIndex == list.Count -1)
            </summary>
            <param name="partitionCount">specified number of partitions</param>
            <returns>a list of partitions</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1">
            <summary>
            Static Partition for IList/Array.
            This class implements all methods required by IEnumerator interface, except for the Current property.
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster element
            retrieval.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an instance of StaticIndexRangePartition
            </summary>
            <param name="startIndex">the start index in the source collection for the current partition </param>
            <param name="endIndex">the end index in the source collection for the current partition</param>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Current">
            <summary>
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster
            element retrieval.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Dispose">
            <summary>
            We don't dispose the source for IList and array
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.MoveNext">
            <summary>
            Moves to the next item
            Before the first MoveNext is called: _offset == _startIndex-1;
            </summary>
            <returns>true if successful, false if there is no item left</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForIList`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForIList`1">
            <summary>
            Inherits from StaticIndexRangePartition
            Provides customized implementation of Current property
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForArray`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition for Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForArray`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedInt">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedBool">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedLong">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.EnumerablePartitionerOptions">
            <summary>
            Out-of-the-box partitioners are created with a set of default behaviors.
            For example, by default, some form of buffering and chunking will be employed to achieve
            optimal performance in the common scenario where an <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation is fast and
            non-blocking.  These behaviors can be overridden via this enumeration.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.None">
            <summary>
            Use the default behavior (i.e., use buffering to achieve optimal performance)
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.NoBuffering">
            <summary>
            Creates a partitioner that will take items from the source enumerable one at a time
            and will not use intermediate storage that can be accessed more efficiently by multiple threads.
            This option provides support for low latency (items will be processed as soon as they are available from
            the source) and partial support for dependencies between items (a thread cannot deadlock waiting for an item
            that it, itself, is responsible for processing).
            </summary>
        </member>
        <member name="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:System.Collections.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:System.Collections.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="T:System.Gen2GcCallback">
            <summary>
            Schedules a callback roughly every gen 2 GC (you may see a Gen 0 an Gen 1 but only once)
            (We can fix this by capturing the Gen 2 count at startup and testing, but I mostly don't care)
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Boolean})">
            <summary>
            Schedule 'callback' to be called in the next GC.  If the callback returns true it is
            rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop.
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Object,System.Boolean},System.Object)">
             <summary>
             Schedule 'callback' to be called in the next GC.  If the callback returns true it is
             rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop.
            
             NOTE: This callback will be kept alive until either the callback function returns false,
             or the target object dies.
             </summary>
        </member>
        <member name="M:System.HashCode.AddBytes(System.ReadOnlySpan{System.Byte})">
            <summary>Adds a span of bytes to the hash code.</summary>
            <param name="value">The span.</param>
            <remarks>
            This method does not guarantee that the result of adding a span of bytes will match
            the result of adding the same bytes individually.
            </remarks>
        </member>
        <member name="T:System.MathEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="M:System.MathEx.Clamp(System.Byte,System.Byte,System.Byte)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Decimal,System.Decimal,System.Decimal)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Double,System.Double,System.Double)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int16,System.Int16,System.Int16)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int32,System.Int32,System.Int32)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Int64,System.Int64,System.Int64)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.IntPtr,System.IntPtr,System.IntPtr)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.SByte,System.SByte,System.SByte)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.Single,System.Single,System.Single)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt16,System.UInt16,System.UInt16)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt32,System.UInt32,System.UInt32)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UInt64,System.UInt64,System.UInt64)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="M:System.MathEx.Clamp(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
             <summary>Returns <paramref name="value" /> clamped to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</summary>
             <param name="value">The value to be clamped.</param>
             <param name="min">The lower bound of the result.</param>
             <param name="max">The upper bound of the result.</param>
             <returns>
               <paramref name="value" /> if <paramref name="min" />  <paramref name="value" />  <paramref name="max" />.
            
               -or-
            
               <paramref name="min" /> if <paramref name="value" /> &lt; <paramref name="min" />.
            
               -or-
            
               <paramref name="max" /> if <paramref name="max" /> &lt; <paramref name="value" />.
             </returns>
        </member>
        <member name="T:System.Memory`1">
            <summary>
            Memory represents a contiguous region of arbitrary memory similar to <see cref="T:System.Span`1"/>.
            Unlike <see cref="T:System.Span`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 0 index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.op_Implicit(`0[])~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.ArraySegment{`0})~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.Memory{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Memory`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.Memory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Memory`1.ToString">
            <summary>
            For <see cref="T:System.Memory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="P:System.Memory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.Memory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.Memory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.Memory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.Memory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            Returns true if the object is Memory or ReadOnlyMemory and if both objects point to the same array and have the same length.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Memory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Memory`1.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
        </member>
        <member name="T:System.MemoryExtensions">
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing white-space characters from the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading and trailing occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all trailing occurrences of a specified character.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing occurrences of a set of characters specified 
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
            <summary>
            Indicates whether the specified span contains only white-space characters.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T). 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1. 
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T). 
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
            <summary>
            Reverses the sequence of the elements in the entire span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
            <summary>
            Creates a new span over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
            <summary>
            Creates a new span over the portion of the target array segment.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
            <summary>
            Creates a new memory over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=array.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
            <summary>
            Creates a new memory over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
             <summary>
             Copies the contents of the array into the span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
             
            <param name="source">The array to copy items from.</param>
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
             <summary>
             Copies the contents of the array into the memory. If the source
             and destinations overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
             
            <param name="source">The array to copy items from.</param>
             <param name="destination">The memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
            <summary>
            Creates a new span over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Returns a value indicating whether the specified <paramref name="value"/> occurs within the <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether this <paramref name="span"/> and the specified <paramref name="other"/> span have the same characters
            when compared using the specified <paramref name="comparisonType"/> option.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Compares the specified <paramref name="span"/> and <paramref name="other"/> using the specified <paramref name="comparisonType"/>,
            and returns an integer that indicates their relative position in the sort order.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified <paramref name="value"/> in the current <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="culture"/> is null.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="culture"/> is null.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <remarks>If the source and destinations overlap, this method behaves as if the original values are in
            a temporary location before the destination is overwritten.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the end of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the end of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the beginning of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the beginning of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="T:System.ReadOnlyMemory`1">
            <summary>
            Represents a contiguous region of memory, similar to <see cref="T:System.ReadOnlySpan`1"/>.
            Unlike <see cref="T:System.ReadOnlySpan`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(System.Object,System.Int32,System.Int32)">
            <summary>Creates a new memory over the existing object, start, and length. No validation is performed.</summary>
            <param name="obj">The target object.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(`0[])~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToString">
            <summary>
            For <see cref="T:System.ReadOnlyMemory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the read-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the readonly-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.ReadOnlyMemory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetHashCode">
            <summary>Returns the hash code for this <see cref="T:System.ReadOnlyMemory`1"/></summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetObjectStartLength(System.Int32@,System.Int32@)">
            <summary>Gets the state of the memory as individual fields.</summary>
            <param name="start">The offset.</param>
            <param name="length">The count.</param>
            <returns>The object.</returns>
        </member>
        <member name="T:System.ReadOnlySpan`1">
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Length">
            <summary>
            The number of items in the read-only span.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Inequality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(`0[])~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Empty">
            <summary>
            Returns a 0-length read-only span whose base is the null pointer.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.ReadOnlySpan`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.ReadOnlySpan`1"/>.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[])">
            <summary>
            Creates a new read-only span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new read-only span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the read-only span.</param>
            <param name="length">The number of items in the read-only span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new read-only span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.ReadOnlySpan`1.Item(System.Int32)">
            <summary>
            Returns the specified element of the read-only span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <param name="destination">The span to copy items into.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when the destination Span is shorter than the source Span.
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
            <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Equality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToString">
            <summary>
            For <see cref="T:System.Span`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToArray">
            <summary>
            Copies the contents of this read-only span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.DangerousGetPinnableReference">
            <summary>
            This method is obsolete, use System.Runtime.InteropServices.MemoryMarshal.GetReference instead.
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="T:System.Span`1">
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.Span`1.Length">
            <summary>
            The number of items in the span.
            </summary>
        </member>
        <member name="P:System.Span`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="P:System.Span`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.Span`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.Span`1.Enumerator.#ctor(System.Span{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.Span`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.Span`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Span`1.#ctor(`0[])">
            <summary>
            Creates a new span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the span.</param>
            <param name="length">The number of items in the span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.Span`1.Item(System.Int32)">
            <summary>
            Returns a reference to specified element of the Span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.Span`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.Span`1.Clear">
            <summary>
            Clears the contents of this span.
            </summary>
        </member>
        <member name="M:System.Span`1.Fill(`0)">
            <summary>
            Fills the contents of this span with the given value.
            </summary>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Span{`0})">
             <summary>
             Copies the contents of this span into destination span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source Span.
             </exception>
             </summary>
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Span{`0})">
             <summary>
             Copies the contents of this span into destination span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination span is shorter than the source span, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Span`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.ToString">
            <summary>
            For <see cref="T:System.Span`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Span`1.ToArray">
            <summary>
            Copies the contents of this span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.Span`1.DangerousGetPinnableReference">
            <summary>
            This method is obsolete, use System.Runtime.InteropServices.MemoryMarshal.GetReference instead.
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.SpanHelpers.CopyTo``1(``0@,System.Int32,``0@,System.Int32)">
             <summary>
             Implements the copy functionality used by Span and ReadOnlySpan.
            
             NOTE: Fast span implements TryCopyTo in corelib and therefore this implementation
                   is only used by portable span. The code must live in code that only compiles
                   for portable span which means either each individual span implementation
                   of this shared code file. Other shared SpanHelper.X.cs files are compiled
                   for both portable and fast span implementations.
             </summary>
        </member>
        <member name="M:System.SpanHelpers.Add``1(System.IntPtr,System.Int32)">
             <summary>
             Computes "start + index * sizeof(T)", using the unsigned IntPtr-sized multiplication for 32 and 64 bits.
            
             Assumptions:
                 Start and index are non-negative, and already pre-validated to be within the valid range of their containing Span.
            
                 If the byte length (Span.Length * sizeof(T)) does an unsigned overflow (i.e. the buffer wraps or is too big to fit within the address space),
                 the behavior is undefined.
            
             </summary>
        </member>
        <member name="M:System.SpanHelpers.IsReferenceOrContainsReferences``1">
            <summary>
            Determine if a type is eligible for storage in unmanaged memory.
            Portable equivalent of RuntimeHelpers.IsReferenceOrContainsReferences{T}()
            </summary>
        </member>
        <member name="T:System.Numerics.BitOperations">
            <summary>
            Utility methods for intrinsic bit-twiddling operations.
            The methods use hardware intrinsics when available on the underlying platform,
            otherwise they use optimized software fallbacks.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt32)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt64)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt64)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2SoftwareFallback(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            Does not directly use any hardware intrinsics, nor does it incur branching.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2Ceiling(System.UInt32)">
            <summary>Returns the integer (ceiling) log of the specified value, base 2.</summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2Ceiling(System.UInt64)">
            <summary>Returns the integer (ceiling) log of the specified value, base 2.</summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt32)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt64)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.ResetLowestSetBit(System.UInt32)">
            <summary>
            Reset the lowest significant bit in the given value
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.ResetBit(System.UInt32,System.Int32)">
            <summary>
            Reset specific bit in the given value
            </summary>
        </member>
        <member name="T:System.Numerics.BitOperationsEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.Int32)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UInt32)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.Int64)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UInt64)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.IntPtr)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.IsPow2(System.UIntPtr)">
            <summary>
            Evaluate whether a given integral value is a power of 2.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UInt32)">
            <summary>Round the given integral value up to a power of 2.</summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UInt64)">
            <summary>
            Round the given integral value up to a power of 2.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RoundUpToPowerOf2(System.UIntPtr)">
            <summary>
            Round the given integral value up to a power of 2.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
            If <paramref name="value"/> is 0 or the result overflows, returns 0.
            </returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UInt32)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UInt64)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.LeadingZeroCount(System.UIntPtr)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UInt64)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.Log2(System.UIntPtr)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UInt32)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UInt64)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.PopCount(System.UIntPtr)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.Int32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UInt32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.Int64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UInt64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.IntPtr)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.TrailingZeroCount(System.UIntPtr)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateLeft(System.UIntPtr,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32 on a 32-bit process,
            and any value outside the range [0..63] is treated as congruent mod 64 on a 64-bit process.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsEx.RotateRight(System.UIntPtr,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32 on a 32-bit process,
            and any value outside the range [0..63] is treated as congruent mod 64 on a 64-bit process.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="T:System.StringComparerEx">
            <summary>
            Extensions to <see cref="T:System.StringComparer"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="T:System.Threading.MonitorEx">
            <summary>
            Extensions to <see cref="T:System.Threading.Monitor"/> providing consistent access to APIs introduced after the type.
            </summary>
        </member>
        <member name="T:System.Threading.SpinLock">
            <summary>
            Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop
            repeatedly checking until the lock becomes available.
            </summary>
            <remarks>
            <para>
            Spin locks can be used for leaf-level locks where the object allocation implied by using a <see
            cref="T:System.Threading.Monitor"/>, in size or due to garbage collection pressure, is overly
            expensive. Avoiding blocking is another reason that a spin lock can be useful, however if you expect
            any significant amount of blocking, you are probably best not using spin locks due to excessive
            spinning. Spinning can be beneficial when locks are fine grained and large in number (for example, a
            lock per node in a linked list) as well as when lock hold times are always extremely short. In
            general, while holding a spin lock, one should avoid blocking, calling anything that itself may
            block, holding more than one spin lock at once, making dynamically dispatched calls (interface and
            virtuals), making statically dispatched calls into any code one doesn't own, or allocating memory.
            </para>
            <para>
            <see cref="T:System.Threading.SpinLock"/> should only be used when it's been determined that doing so will improve an
            application's performance. It's also important to note that <see cref="T:System.Threading.SpinLock"/> is a value type,
            for performance reasons. As such, one must be very careful not to accidentally copy a SpinLock
            instance, as the two instances (the original and the copy) would then be completely independent of
            one another, which would likely lead to erroneous behavior of the application. If a SpinLock instance
            must be passed around, it should be passed by reference rather than by value.
            </para>
            <para>
            Do not store <see cref="T:System.Threading.SpinLock"/> instances in readonly fields.
            </para>
            <para>
            All members of <see cref="T:System.Threading.SpinLock"/> are thread-safe and may be used from multiple threads
            concurrently.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock"/>
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock"/> tracks thread ownership.
            </remarks>
            <param name="enableThreadOwnerTracking">Whether to capture and use thread IDs for debugging
            purposes.</param>
        </member>
        <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock"/>
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock"/> tracks thread ownership.
            </remarks>
            <summary>
            Acquires the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="lockTaken"/> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <remarks>
            <see cref="T:System.Threading.SpinLock"/> is a non-reentrant lock, meaning that if a thread holds the lock, it is
            not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's
            enabled is available through <see cref="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled"/>), an exception will be
            thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership
            tracking is disabled, attempting to enter a lock already held will result in deadlock.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling Enter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block waiting for the lock to be available. If the
            lock is not available when TryEnter is called, it will return immediately without any further
            spinning.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref
            name="timeout"/>
            has expired.
            </remarks>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/> milliseconds.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref
            name="millisecondsTimeout"/> has expired.
            </remarks>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnter(System.Int32,System.Boolean@)">
            <summary>
            Try acquire the lock with long path, this is usually called after the first path in Enter and
            TryEnter failed The reason for short path is to make it inline in the run time which improves the
            performance. This method assumed that the parameter are validated in Enter or TryEnter method.
            </summary>
            <param name="millisecondsTimeout">The timeout milliseconds</param>
            <param name="lockTaken">The lockTaken param</param>
        </member>
        <member name="M:System.Threading.SpinLock.DecrementWaiters">
            <summary>
            decrements the waiters, in case of the timeout is expired
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnterWithThreadTracking(System.Int32,System.UInt32,System.Boolean@)">
            <summary>
            ContinueTryEnter for the thread tracking mode enabled
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.Exit">
            <summary>
            Releases the lock.
            </summary>
            <remarks>
            The default overload of <see cref="M:System.Threading.SpinLock.Exit"/> provides the same behavior as if calling <see
            cref="M:System.Threading.SpinLock.Exit(System.Boolean)"/> using true as the argument, but Exit() could be slightly faster than Exit(true).
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
            <summary>
            Releases the lock.
            </summary>
            <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads.
            </param>
            <remarks>
            Calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)"/> with the <paramref name="useMemoryBarrier"/> argument set to
            true will improve the fairness of the lock at the expense of some performance. The default <see
            cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>
            overload behaves as if specifying true for <paramref name="useMemoryBarrier"/>.
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.ExitSlowPath(System.Boolean)">
            <summary>
            The slow path for exit method if the fast path failed
            </summary>
            <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads
            </param>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeld">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
            <summary>
            Gets whether the lock is held by the current thread.
            </summary>
            <remarks>
            If the lock was initialized to track owner threads, this will return whether the lock is acquired
            by the current thread. It is invalid to use this property when the lock was initialized to not
            track thread ownership.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thread ownership tracking is disabled.
            </exception>
        </member>
        <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
            <summary>Gets whether thread ownership tracking is enabled for this instance.</summary>
        </member>
        <member name="T:System.Threading.SpinLock.SystemThreading_SpinLockDebugView">
            <summary>
            internal class used by debug type proxy attribute to display the owner thread ID
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.#ctor(System.Threading.SpinLock)">
            <summary>
            SystemThreading_SpinLockDebugView constructor
            </summary>
            <param name="spinLock">The SpinLock to be proxied.</param>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeldByCurrentThread">
            <summary>
            Checks if the lock is held by the current thread or not
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.OwnerThreadID">
            <summary>
            Gets the current owner thread, zero if it is released
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeld">
            <summary>
             Gets whether the lock is currently held by any thread or not.
            </summary>
        </member>
        <member name="T:System.Threading.SpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.SpinWait"/> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel(R) processors employing Hyper-Threading
            technology, it helps to prevent hardware thread starvation. SpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
            <para>
            <see cref="T:System.Threading.SpinWait"/> is a value type, which means that low-level code can utilize SpinWait without
            fear of unnecessary allocation overheads. SpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor"/>. For most purposes where spin waiting is required, however,
            the <see cref="T:System.Threading.SpinWait"/> type should be preferred over the <see
            cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> method.
            </para>
            <para>
            While SpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  SpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of SpinWait.
            </para>
            </remarks>
        </member>
        <member name="F:System.Threading.SpinWait.SpinCountforSpinBeforeWait">
             <summary>
             A suggested number of spin iterations before doing a proper wait, such as waiting on an event that becomes signaled
             when the resource becomes available.
             </summary>
             <remarks>
             These numbers were arrived at by experimenting with different numbers in various cases that currently use it. It's
             only a suggested value and typically works well when the proper wait is something like an event.
            
             Spinning less can lead to early waiting and more context switching, spinning more can decrease latency but may use
             up some CPU time unnecessarily. Depends on the situation too, for instance SemaphoreSlim uses more iterations
             because the waiting there is currently a lot more expensive (involves more spinning, taking a lock, etc.). It also
             depends on the likelihood of the spin being successful and how long the wait would be but those are not accounted
             for here.
             </remarks>
        </member>
        <member name="P:System.Threading.SpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:System.Threading.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:System.Threading.SpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:System.Threading.SpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce">
            <summary>
            Performs a single spin.
            </summary>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
            <summary>
            Performs a single spin.
            </summary>
            <param name="sleep1Threshold">
            A minimum spin count after which <code>Thread.Sleep(1)</code> may be used. A value of <code>-1</code> may be used to
            disable the use of <code>Thread.Sleep(1)</code>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="sleep1Threshold"/> is less than <code>-1</code>.
            </exception>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
            <remarks>
            This makes <see cref="M:System.Threading.SpinWait.SpinOnce"/> and <see cref="P:System.Threading.SpinWait.NextSpinWillYield"/> behave as though no calls
            to <see cref="M:System.Threading.SpinWait.SpinOnce"/> had been issued on this instance. If a <see cref="T:System.Threading.SpinWait"/> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait,
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="T:System.Threading.TimeoutHelper">
            <summary>
            A helper class to capture a start time using <see cref="P:System.Environment.TickCount"/> as a time in milliseconds.
            Also updates a given timeout by subtracting the current time from the start time.
            </summary>
        </member>
        <member name="M:System.Threading.TimeoutHelper.GetTime">
            <summary>
            Returns <see cref="P:System.Environment.TickCount"/> as a start time in milliseconds as a <see cref="T:System.UInt32"/>.
            <see cref="P:System.Environment.TickCount"/> rolls over from positive to negative every ~25 days, then ~25 days to back to positive again.
            <see cref="T:System.UInt32"/> is used to ignore the sign and double the range to 50 days.
            </summary>
        </member>
        <member name="M:System.Threading.TimeoutHelper.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Helper function to measure and update the elapsed time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The original wait timeout in milliseconds</param>
            <returns>The new wait time in milliseconds, or -1 if the time expired</returns>
        </member>
        <member name="T:System.Threading.ThreadLocal`1">
            <summary>
            Provides thread-local storage of data.
            </summary>
            <typeparam name="T">Specifies the type of data stored per-thread.</typeparam>
            <remarks>
            <para>
            With the exception of <see cref="M:System.Threading.ThreadLocal`1.Dispose"/>, all public and protected members of
            <see cref="T:System.Threading.ThreadLocal`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance.
            </summary>
            <param name="trackAllValues">Whether to track all values set on the instance and expose them through the Values property.</param>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance with the
            specified <paramref name="valueFactory"/> function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func`1"/> invoked to produce a lazily-initialized value when
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value"/> without it having been previously initialized.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="valueFactory"/> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance with the
            specified <paramref name="valueFactory"/> function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func`1"/> invoked to produce a lazily-initialized value when
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value"/> without it having been previously initialized.
            </param>
            <param name="trackAllValues">Whether to track all values set on the instance and expose them via the Values property.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="valueFactory"/> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Finalize">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal`1" /> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal`1" /> instance.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal`1"/>, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal`1" /> instance.
            </summary>
            <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.ThreadLocal`1.Dispose"/>.
            </param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal`1"/>, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.ToString">
            <summary>Creates and returns a string representation of this instance for the current thread.</summary>
            <returns>The result of calling <see cref="M:System.Object.ToString"/> on the <see cref="P:System.Threading.ThreadLocal`1.Value"/>.</returns>
            <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Threading.ThreadLocal`1.Value"/> for the current thread is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value"/> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
            <remarks>
            Calling this method forces initialization for the current thread, as is the
            case with accessing <see cref="P:System.Threading.ThreadLocal`1.Value"/> directly.
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value of this instance for the current thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value"/> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
            <remarks>
            If this instance was not previously initialized for the current thread,
            accessing <see cref="P:System.Threading.ThreadLocal`1.Value"/> will attempt to initialize it. If an initialization function was
            supplied during the construction, that initialization will happen by invoking the function
            to retrieve the initial value for <see cref="P:System.Threading.ThreadLocal`1.Value"/>.  Otherwise, the default value of
            <typeparamref name="T"/> will be used.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.CreateLinkedSlot(System.Threading.ThreadLocal{`0}.LinkedSlotVolatile[],System.Int32,`0)">
            <summary>
            Creates a LinkedSlot and inserts it into the linked list for this ThreadLocal instance.
            </summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.Values">
            <summary>
            Gets a list for all of the values currently stored by all of the threads that have accessed this instance.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GetValuesAsList">
            <summary>Gets all of the threads' values in a list.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValuesCountForDebugDisplay">
            <summary>Gets the number of threads that have data in this instance.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
            <summary>
            Gets whether <see cref="P:System.Threading.ThreadLocal`1.Value"/> is initialized on the current thread.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValueForDebugDisplay">
            <summary>Gets the value of the ThreadLocal&lt;T&gt; for debugging display purposes. It takes care of getting
            the value for the current thread in the ThreadLocal mode.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValuesForDebugDisplay">
            <summary>Gets the values of all threads that accessed the ThreadLocal&lt;T&gt;.</summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GrowTable(System.Threading.ThreadLocal{`0}.LinkedSlotVolatile[]@,System.Int32)">
            <summary>
            Resizes a table to a certain length (or larger).
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GetNewTableSize(System.Int32)">
            <summary>
            Chooses the next larger table size
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.LinkedSlotVolatile">
            <summary>
            A wrapper struct used as LinkedSlotVolatile[] - an array of LinkedSlot instances, but with volatile semantics
            on array accesses.
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.LinkedSlot">
             <summary>
             A node in the doubly-linked list stored in the ThreadLocal instance.
            
             The value is stored in one of two places:
            
                 1. If SlotArray is not null, the value is in SlotArray.Table[id]
                 2. If SlotArray is null, the value is in FinalValue.
             </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.IdManager">
            <summary>
            A manager class that assigns IDs to ThreadLocal instances
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.FinalizationHelper">
             <summary>
             A class that facilitates ThreadLocal cleanup after a thread exits.
            
             After a thread with an associated thread-local table has exited, the FinalizationHelper
             is responsible for removing back-references to the table. Since an instance of FinalizationHelper
             is only referenced from a single thread-local slot, the FinalizationHelper will be GC'd once
             the thread has exited.
            
             The FinalizationHelper then locates all LinkedSlot instances with back-references to the table
             (all those LinkedSlot instances can be found by following references from the table slots) and
             releases the table so that it can get GC'd.
             </summary>
        </member>
        <member name="T:System.Threading.SystemThreading_ThreadLocalDebugView`1">
            <summary>A debugger view of the ThreadLocal&lt;T&gt; to surface additional debugging properties and
            to ensure that the ThreadLocal&lt;T&gt; does not become initialized if it was not already.</summary>
        </member>
        <member name="M:System.Threading.SystemThreading_ThreadLocalDebugView`1.#ctor(System.Threading.ThreadLocal{`0})">
            <summary>Constructs a new debugger view object for the provided ThreadLocal object.</summary>
            <param name="tlocal">A ThreadLocal object to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.IsValueCreated">
            <summary>Returns whether the ThreadLocal object is initialized or not.</summary>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.Value">
            <summary>Returns the value of the ThreadLocal object.</summary>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.Values">
            <summary>Return all values for all threads that have accessed this instance.</summary>
        </member>
        <member name="T:System.Threading.Volatile">
            <summary>Methods for accessing memory with volatile semantics.</summary>
        </member>
        <member name="T:System.ITupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="P:System.Tuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's second component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object based on a specified comparison method.
             </summary>
             <param name="other">The object to compare with this instance.</param>
             <param name="comparer">An object that defines the method to use to evaluate whether the two objects are equal.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             This member is an explicit interface member implementation. It can be used only when the
              <see cref="T:System.ValueTuple`2"/> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable"/> interface.
            
             The <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation is called only if <c>other</c> is not <see langword="null"/>,
              and if it can be successfully cast (in C#) or converted (in Visual Basic) to a <see cref="T:System.ValueTuple`2"/>
              whose components are of the same types as those of the current instance. The IStructuralEquatable.Equals(Object, IEqualityComparer) method
              first passes the <see cref="F:System.ValueTuple`2.Item1"/> values of the <see cref="T:System.ValueTuple`2"/> objects to be compared to the
              <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation. If this method call returns <see langword="true"/>, the method is
              called again and passed the <see cref="F:System.ValueTuple`2.Item2"/> values of the two <see cref="T:System.ValueTuple`2"/> instances.
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
    </members>
</doc>
